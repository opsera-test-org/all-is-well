name: Bootstrap Infrastructure

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to bootstrap'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev

permissions:
  contents: write
  id-token: write

env:
  APP_NAME: all-is-well-feb
  TENANT: opsera
  REGION: us-west-2

jobs:
  bootstrap:
    name: Bootstrap ${{ inputs.environment }} Environment
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsRole
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Get AWS Account ID dynamically
        id: aws-account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=$AWS_ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "✓ AWS Account ID: $AWS_ACCOUNT_ID"

      - name: Create ECR repository
        id: create-ecr
        run: |
          REPO_NAME="${{ env.TENANT }}/${{ env.APP_NAME }}"

          if aws ecr describe-repositories --repository-names "$REPO_NAME" --region ${{ env.REGION }} 2>/dev/null; then
            echo "✓ ECR repository already exists: $REPO_NAME"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "Creating ECR repository: $REPO_NAME"
            aws ecr create-repository \
              --repository-name "$REPO_NAME" \
              --region ${{ env.REGION }} \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256
            echo "✓ ECR repository created: $REPO_NAME"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

          ECR_URI="${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.REGION }}.amazonaws.com/$REPO_NAME"
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "✓ ECR URI: $ECR_URI"

      - name: Configure kubectl for spoke cluster
        run: |
          aws eks update-kubeconfig --name ${{ secrets.SPOKE_CLUSTER }} --region ${{ env.REGION }}
          kubectl config current-context
          echo "✓ Connected to spoke cluster: ${{ secrets.SPOKE_CLUSTER }}"

      - name: Create namespace
        run: |
          NAMESPACE="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ inputs.environment }}"

          if kubectl get namespace "$NAMESPACE" 2>/dev/null; then
            echo "✓ Namespace already exists: $NAMESPACE"
          else
            kubectl create namespace "$NAMESPACE"
            kubectl label namespace "$NAMESPACE" \
              tenant=${{ env.TENANT }} \
              app=${{ env.APP_NAME }} \
              environment=${{ inputs.environment }} \
              managed-by=opsera-cicd
            echo "✓ Namespace created: $NAMESPACE"
          fi

      - name: Create ECR image pull secret
        run: |
          NAMESPACE="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ inputs.environment }}"
          SECRET_NAME="ecr-registry-secret"

          # Get ECR login token
          ECR_TOKEN=$(aws ecr get-login-password --region ${{ env.REGION }})
          ECR_REGISTRY="${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.REGION }}.amazonaws.com"

          # Delete existing secret if present
          kubectl delete secret "$SECRET_NAME" -n "$NAMESPACE" --ignore-not-found=true

          # Create new secret
          kubectl create secret docker-registry "$SECRET_NAME" \
            --docker-server="$ECR_REGISTRY" \
            --docker-username=AWS \
            --docker-password="$ECR_TOKEN" \
            --namespace="$NAMESPACE"

          echo "✓ ECR secret created/refreshed: $SECRET_NAME"

      - name: Deploy base manifests
        run: |
          NAMESPACE="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ inputs.environment }}"

          # Apply manifests using kustomize
          kubectl apply -k k8s/${{ inputs.environment }}/ --namespace="$NAMESPACE"

          echo "✓ Base manifests deployed to namespace: $NAMESPACE"

      - name: Verify deployment
        run: |
          NAMESPACE="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ inputs.environment }}"

          echo "Namespace status:"
          kubectl get namespace "$NAMESPACE" -o wide

          echo -e "\nResources in namespace:"
          kubectl get all -n "$NAMESPACE"

          echo "✓ Bootstrap complete for ${{ inputs.environment }} environment"

      - name: Summary
        run: |
          echo "## Bootstrap Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Environment:** ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "✅ **ECR Repository:** ${{ steps.create-ecr.outputs.ecr_uri }}" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Namespace:** ${{ env.TENANT }}-${{ env.APP_NAME }}-${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Spoke Cluster:** ${{ secrets.SPOKE_CLUSTER }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Push code to 'main' branch to trigger CI/CD" >> $GITHUB_STEP_SUMMARY
          echo "2. Monitor deployment at ArgoCD: https://${{ secrets.ARGOCD_SERVER }}" >> $GITHUB_STEP_SUMMARY
          echo "3. Access application at: https://${{ env.APP_NAME }}-${{ inputs.environment }}.agent.opsera.dev" >> $GITHUB_STEP_SUMMARY
